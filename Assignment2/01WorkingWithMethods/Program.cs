/* C# Assignment 02
    Introduction to C# and Data Types
    SEP Full Stack
    Timothy Yang
    May 29th, 2024
*/

/*
03 Object-Oriented Programming
Test your knowledge
1. What are the six combinations of access modifier keywords and what do they do? 
public: The member is accessible from any other code.
    private: The member is accessible only within the same class.
    protected: The member is accessible within the same class and by derived class instances.
    internal: The member is accessible within the same assembly, but not from another assembly.
    protected internal: The member is accessible within the same assembly and also in derived classes in other assemblies.
    private protected: The member is accessible within the same class and derived classes within the same assembly.
2. What is the difference between the static, const, and readonly keywords when applied to
a type member?
    static: The member belongs to the type itself rather than to a specific object instance. It can be accessed without creating an instance of the class.
    const: The member's value is set at compile-time and cannot be changed. It is implicitly static.
    readonly: The member's value can be set either at the time of declaration or in the constructor, but not elsewhere.
3. What does a constructor do?
    A constructor initializes a new instance of a class. It can set default values, allocate resources, and perform other setup tasks when an object is created.
4. Why is the partial keyword useful?
    The partial keyword allows a class, struct, or interface to be split into multiple files. This can be useful for organizing code, especially in large projects, or when code is generated by a tool.
5. What is a tuple?
    A tuple is a data structure that can hold a fixed number of items, each of potentially different types. It provides a way to group multiple values without creating a class.
6. What does the C# record keyword do?
    The record keyword defines a reference type that provides built-in functionality for encapsulating data. It offers value equality, immutability (by default), and concise syntax for creating data-carrying types.
7. What does overloading and overriding mean?
    Overloading: Defining multiple methods with the same name but different signatures (parameter lists) within the same class.
    Overriding: Providing a new implementation for a method in a derived class that is already defined in the base class using the override keyword.
8. What is the difference between a field and a property?
    Field: A variable that is directly accessible within a class or struct.
    Property: A member that provides a flexible mechanism to read, write, or compute the value of a private field, usually through get and set accessors.
9. How do you make a method parameter optional?
    By providing a default value for the parameter in the method signature. For example: void Method(int x = 0)
10. What is an interface and how is it different from abstract class?
    An interface defines a contract with methods, properties, events, or indexers that a class or struct must implement.
    Differences:
    Interfaces cannot contain implementation; abstract classes can.
    A class can implement multiple interfaces but can only inherit from one base class (abstract or otherwise).
    Interfaces cannot have constructors or fields; abstract classes can.
11. What accessibility level are members of an interface?
    Members of an interface are implicitly public and cannot have any other access modifiers.
12. True/False. Polymorphism allows derived classes to provide different implementations of the same method.
    True
13. True/False. The override keyword is used to indicate that a method in a derived class is providing its own implementation of a method.
    True
14. True/False. The new keyword is used to indicate that a method in a derived class is providing its own implementation of a method.
    True (but it hides the base class method, not overrides it)
15. True/False. Abstract methods can be used in a normal (non-abstract) class.
    False
16. True/False. Normal (non-abstract) methods can be used in an abstract class.
    True
17. True/False. Derived classes can override methods that were virtual in the base class.
    True
18. True/False. Derived classes can override methods that were abstract in the base class.
    True
19. True/False. In a derived class, you can override a method that was neither virtual nor abstract in the base class.
    False
20. True/False. A class that implements an interface does not have to provide an implementation for all of the members of the interface.
    False
21. True/False. A class that implements an interface is allowed to have other members that aren’t defined in the interface.
    True
22. True/False. A class can have more than one base class.
    False
23. True/False. A class can implement more than one interface.
    True
*/

/*
Working with methods
1. Let’s make a program that uses methods to accomplish a task. Let’s take an array and
reverse the contents of it. For example, if you have 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, it would
become 10, 9, 8, 7, 6, 5, 4, 3, 2, 1.
To accomplish this, you’ll create three methods: one to create the array, one to reverse the
array, and one to print the array at the end.
Your Mainmethod will look something like this:
static void Main(string[] args) {
int[] numbers = GenerateNumbers();
Reverse(numbers);
PrintNumbers(numbers);
}
The GenerateNumbersmethod should return an array of 10 numbers. (For bonus points,
change the method to allow the desired length to be passed in, instead of just always
being 10.)
The PrintNumbersmethod should use a foror foreachloop to print out each item in the
array. The Reversemethod will be the hardest. Give it a try and see what you can make
happen. If you get
stuck, here’s a couple of hints:
Hint #1:To swap two values, you will need to place the value of one variable in a temporary
location to make the swap:
// Swapping a and b.
int a = 3;
int b = 5;
int temp = a;
a = b;
b = temp;
Hint #2:Getting the right indices to swap can be a challenge. Use a forloop, starting at 0
and going up to the length of the array / 2. The number you use in the forloop will be the
index of the first number to swap, and the other one will be the length of the array minus
the index minus 1. This is to account for the fact that the array is 0-based. So basically,
you’ll be swapping array[index]with array[arrayLength – index – 1]
*/

using System;

namespace WorkingWithMethods
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] numbers = ArrayUtilities.GenerateNumbers(10);
            Console.WriteLine("Original Array:");
            ArrayUtilities.PrintNumbers(numbers);

            ArrayUtilities.Reverse(numbers);
            Console.WriteLine("Reversed Array:");
            ArrayUtilities.PrintNumbers(numbers);
        }
    }
}
